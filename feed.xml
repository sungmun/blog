<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SleepyGom</title>
  
  <subtitle>Developer Blog</subtitle>
  <link href="https://sungmun.github.io/blog/feed.xml" rel="self"/>
  
  <link href="https://sungmun.github.io/blog/"/>
  <updated>2024-01-19T07:37:03.829Z</updated>
  <id>https://sungmun.github.io/blog/</id>
  
  <author>
    <name>sungmun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scale Out 가능한 Socket.io 서버 구축하기</title>
    <link href="https://sungmun.github.io/blog/2020/07/18/Scale-Out-%EA%B0%80%EB%8A%A5%ED%95%9C-Socket-io-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/"/>
    <id>https://sungmun.github.io/blog/2020/07/18/Scale-Out-%EA%B0%80%EB%8A%A5%ED%95%9C-Socket-io-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/</id>
    <published>2020-07-18T08:11:18.000Z</published>
    <updated>2024-01-19T07:37:03.829Z</updated>
    
    <content type="html"><![CDATA[<p>이번에 신규 서비스를 런칭하면서 <code>webPush</code>를 이용한 알림 시스템을 구축했으나, Ios에서 <code>webPush</code>를 지원을 하지 않는다는 문제로 Socket.io를 이용하여 실시간 알림 시스템을 구축을 하면서 제일 고민한 Scale Out에 대한 부분이다.</p><h2 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h2><p>기본적으로 Socket.io는 클라이언트에서 직접적으로 커넥션을 연결해주고, 그 연결된 커넥션으로 서버에서 메세지를 받고 보내는 동작을 한다. </p><p>문제는 서버를 구축시 대부분의 이벤트가 하나의 클라이언트가 다른 모든 클라이언트에게 메세지를 보내는 브로드캐스팅이 대부분이라는 것이다. 만약 서버가 여러대 일경우 모든클라이언트에게 전달이 되는것이 아닌 같은 서버와 커넥션이 연결된 클라이언트에게만 이벤트가 전달되고 다른서버와 연결된 클라이언트에게는 전달이 되지 않는 문제가 생긴다.</p><h2 id="해결-방안"><a href="#해결-방안" class="headerlink" title="해결 방안"></a>해결 방안</h2><p>이 문제를 해결하기 위해서는 이벤트가 발생시 이 이벤트를 다른 서버에 전파를 해줘야하는데 이 부분에서 가장 간단하면서 빠른 방법은 redis를 이용하여 Socket서버간 Pub&#x2F;Sub해주는 게 좋아 보였다. </p><p>이와 관련된 redis를 찾아보니, <a href="https://github.com/socketio/socket.io-redis">socket.io-redis</a> 라는 라이브러리가 있어서 사용을 하니 매우 간단하게 redis를 이용하여 Socket 서버간 전파가 가능했다.</p><h2 id="참고-코드"><a href="#참고-코드" class="headerlink" title="참고 코드"></a>참고 코드</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">&#x27;http&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> socket <span class="keyword">from</span> <span class="string">&#x27;socket.io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> socketRedis <span class="keyword">from</span> <span class="string">&#x27;socket.io-redis&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">server</span>: http.<span class="property">Server</span> = <span class="keyword">new</span> http.<span class="title class_">Server</span>(app);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>||<span class="string">`environment.port`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket =  <span class="title function_">socket</span>(server);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisAdapter = <span class="title function_">socketRedis</span>(&#123; <span class="attr">host</span>: <span class="string">`environment.redis.uri`</span>, <span class="attr">port</span>: <span class="string">`environment.redis.port`</span> &#125;);</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">adapter</span>(redisAdapter);</span><br><span class="line">socket</span><br><span class="line">    .<span class="title function_">of</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    .<span class="property">adapter</span></span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">error</span> =&gt;</span></span><br><span class="line">      logger.<span class="title function_">error</span>(<span class="string">&#x27;socket Redis Error &#x27;</span>, &#123; error &#125;),</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>간단한 코드로, 위 부분만 되면 <code>Scale-out</code>에 대비된 Socket 서버 구축이 완료된다.</p><h2 id="참고-사항"><a href="#참고-사항" class="headerlink" title="참고 사항"></a>참고 사항</h2><p>구현시 참고할 사항들은 <a href="https://woowabros.github.io/woowabros/2017/09/12/realtime-service.html">배달의민족 포스트</a> 에 잘 소개 되어있으며, <code>AWS ELB</code>를 이용하는 경우 대상 그룹 설정에서 <code>Stickiness</code> 을 체크해주고 <code>Stickiness duration</code>을 넉넉하게 정해줘야 한다. 만약 이부분이 제대로 되지 않으면, 클라이언트쪽에서 연결이 계속 끊어지는 문제가 발생한다  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;이번에 신규 서비스를 런칭하면서 &lt;code&gt;webPush&lt;/code&gt;를 이용한 알림 시스템을 구축했으나, Ios에서 &lt;code&gt;webPush&lt;/code&gt;를 지원을 하지 않는다는 문제로 Socket.io를 이용하여 실시간 알림 시스템을 구축을 하면</summary>
      
    
    
    
    
    <category term="Node" scheme="https://sungmun.github.io/blog/tags/Node/"/>
    
    <category term="Socket.io" scheme="https://sungmun.github.io/blog/tags/Socket-io/"/>
    
    <category term="ScaleOut" scheme="https://sungmun.github.io/blog/tags/ScaleOut/"/>
    
  </entry>
  
  <entry>
    <title>KCP 휴대폰 본인인증 컨버팅</title>
    <link href="https://sungmun.github.io/blog/2020/07/05/Kcp%20%ED%9C%B4%EB%8C%80%ED%8F%B0%20%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%20Node%20%EA%B8%B0%EB%B0%98%20%EC%BB%A8%EB%B2%84%ED%8C%85/"/>
    <id>https://sungmun.github.io/blog/2020/07/05/Kcp%20%ED%9C%B4%EB%8C%80%ED%8F%B0%20%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%20Node%20%EA%B8%B0%EB%B0%98%20%EC%BB%A8%EB%B2%84%ED%8C%85/</id>
    <published>2020-07-05T09:13:20.000Z</published>
    <updated>2024-01-19T07:37:03.829Z</updated>
    
    <content type="html"><![CDATA[<p>현재 회사에서 나온 이슈인데, 하나의 고객이 SNS 로그인을 이용해서 여러개의 계정을 가지고 있어 히스토리가 분산이 되는 이슈가 있었다. 그래서 회사에서 KCP 본인 인증 서비스를 도입하면서 겪은 문제와 해결방법들등을 공유 한다. (더 좋은 방법이 있으면 알려주세요 ㅠㅠ)</p><h2 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h2><ul><li>제휴전까지는 참고용으로 알수 있는 문서가 없다.(다른 본인 서비스와 비교를 할수 있는 건더기가 하나도 없어서 그저 운에 기대는 수 밖에 없다.)</li><li>제휴후에 문서를 받고나서 확인을 해보니 서버쪽 예제코드는 php밖에 없다. 심지어 대부분의 SNS로그인처럼 쉽게 호출이 어렵고 암호화된 값을 실시간으로 만들어서 kcp쪽에 보내줘야해서 좀 복잡하다.</li><li>kcp에 보내는 방식도 post로 보내야 해서 리다이렉트를 할 수가 없고 조금 많이 복잡하다.</li><li>암호화 할때, 시간관련 고유값이 있어야 하고, 암호화는 kcp에서 제공하는 바이너리 프로그램을 통해서 암호화가 가능하다.</li><li>물론 해독도 마찬가지로 kcp에서 제공하는 바이너리 프로그램을 통해서 해독이 가능하다.</li></ul><h2 id="해결방안"><a href="#해결방안" class="headerlink" title="해결방안"></a>해결방안</h2><p>우선은 회사에 서버개발자들이 전부 Node.js 개발자라 php코드 그대로 가는 부분은 크게 염두에 두지 않았고, node로 컨버팅이 가능한지에 대한 여부를 주로 확인을 했으며, 가능하면 Docker에서 사용이 가능한지도 같이 확인을 했다.</p><p>다행이도 메인이 되는 바이너리 파일을 Node.js 에서 child_process 라이브러리를 이용하여 호출이 가능했고, Docker 여부도 node 이미지가 리눅스 기반이라 메인이 되는 바이너리 파일이 동작이 되는것을 확인했다.</p><h2 id="작업"><a href="#작업" class="headerlink" title="작업"></a>작업</h2><p>우선은 로컬에서 동작이 불가능해서 크게 2개의 환경을 구축하고 작업을 시작했다.</p><ul><li>우선은 정상적을 동작이 가능한지 확인 하기위한, ubuntu 기반의 개발 서버에 docker 없이 샘플로 준 php로 돌아가는 서버</li><li>Docker 의 Node기반의 서버</li></ul><p>우선 php서버는 1번서버이고 node기반의 서버는 2번 서버라고 하겠다.</p><p>우선 서버에 필요한 페이지는 2개정도 필요하므로 예상이 되서 두개의 페이지를 만들기 시작했다,</p><ol><li>서버로 요청이 오면 바로 kcp에서 요청을 원하는 형식에 맞게 보내는 데이터를 만들고 보내는 페이지 </li><li>kcp서버에서 본인 인증이 보낸 암호화된 데이터를 다시 복호화를 해서 유저의 데이터를 수정후 성공 여부를 앱에서 알수 있도록 해주는 페이지</li></ol><h3 id="요청-페이지"><a href="#요청-페이지" class="headerlink" title="요청 페이지"></a>요청 페이지</h3><p>우선 페이지가 간단하고, 유저에게 보여줄 내용이 없는 페이지로 거의 html이 로드 되자마자, 바로 kcp 서버로 요청을 보내기만 하면 되는 페이지다 보니 간단하게 pug템플릿을 통해서 만들수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html(lang=&#x27;ko&#x27;)</span><br><span class="line">    head</span><br><span class="line">        title Certification</span><br><span class="line">    body</span><br><span class="line">        form(method=&#x27;post&#x27; action=url)#from</span><br><span class="line">          each val, key in body</span><br><span class="line">            input(name=key, value=val, type=&#x27;hidden&#x27;)</span><br><span class="line">        script(type=&#x27;text/javascript&#x27;).</span><br><span class="line">            document.getElementById(&#x27;from&#x27;).submit();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 위 와같이 pug파일을 작성하면, 이 페이지가 로드 되자마자 바로 kcp 인증 페이지로 리다이렉트가 된다. </p><p> 이제 body에 들어가는 값들을 만들어주는데, body값은 pug페이지를 렌더링할때, 인자값에 객체로 보내는 값에 body값을 포함해서 보내면 되며, 대부분의 값은 고정이나, <code>ordr_idxx</code> 값이나 <code>hash_key</code> 값은 실시간으로 만들어 줘야하며, <code>site_cd</code>값은 보안상 환경변수로 사용하다가 같이 넣어줘야 한다. 그리고 <code>Ret_URL</code>값은 환경에 따라서 바뀌는 값이라 환경 변수 처리를 하는게 좋다.</p><p> 그리고 <code>up_hash</code>를 만드는 방법은 날짜와 시간을 조합해서 고유의 <code>ordr_idxx</code>, kcp에서 재공하는 <code>site_cd</code>, 그리고 16자리의 <code>hash_key</code>값을 이용해서 클라이언트에서 사용하는 hash값을 만들어준다.</p><p>이때 위에서 계속 말하는 바이너리 파일은 <code>ct_cli</code> 파일인데 다음과 같이 사용하면 해시값을 만들어 준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct_cli lf_CT_CLI__make_hash_data hash_key data </span><br></pre></td></tr></table></figure><p>아 그리고 위에 들어가는 <code>data</code>값은 다음과 같이 조합을 해야한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=<span class="string">`<span class="subst">$&#123;site_cd&#125;</span><span class="subst">$&#123;ordr_idxx&#125;</span><span class="subst">$&#123;web_siteid&#125;</span><span class="subst">$&#123;user_name&#125;</span><span class="subst">$&#123;year&#125;</span><span class="subst">$&#123;month&#125;</span><span class="subst">$&#123;day&#125;</span><span class="subst">$&#123;sex_code&#125;</span><span class="subst">$&#123;local_code&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>위의 데이터에 들어가는 <code>order_idxx</code>값을 만들때의 시간데이터는 요청시의 시간이고, <code>data</code>에 들어가는 <code>$&#123;user_name&#125;$&#123;year&#125;$&#123;month&#125;$&#123;day&#125;$&#123;sex_code&#125;$&#123;local_code&#125;</code>값들은 본인 인증을 요청하는 고객의 정보로, 만약 없으면 넣지 않아도 되는 값이라고 보면 된다,<br>그리고 위의 데이터의 년월일은 포맷이 <code>YYYYMMDD</code>이며, 없는경우 <code>00000000</code>을 넣어주면 된다.</p><p>이 API의 난간은 <code>up_hash</code>를 재대로 만들지 못하면 어디에서 잘못됬는지 찾는데 시간이 걸리는데, 이때, 기존의 php서버에 로그를 찍어서 확인하면 그나마 쉽게 추적이 가능하다.</p><p>그리고 param_opt 변수를 이용할 때, <code>base64</code>로 인코딩을 해줘야 나중에 <code>Ret_URL</code>을 통해서 값을 받을때, 정상적인 응답값을 내려준다.  </p><h3 id="응답-페이지"><a href="#응답-페이지" class="headerlink" title="응답 페이지"></a>응답 페이지</h3><p>이 페이지는 크게 4가지 동작을 해야하는데, 첫번째로는 kcp에서 보내준 데이터중 암호화된 데이터를 체크하는 동작, 암호화된 데이터를 복호화해서 확인하는 작업, 복호화한 데이터를 기반으로 자사 서비스에서 본인 인증여부를 수정하는 작업, 클라이언트에 실패유무를 알여주는 페이지</p><p>우선은 kcp에서 보내준 데이터중 암호화된 데이터를 체크하는 동작은<a href="#%EC%9A%94%EC%B2%AD-%ED%8E%98%EC%9D%B4%EC%A7%80">요청페이지</a> 을 완료했다면 크게 문제없이 완성이 가능하다.</p><p>문제는 암호화된 데이터를 복호화하는 작업이다. 우선은 테스트서버에서만 그런지는 모르겠는데, 불규칙적으로 <code>-4</code>가나온다. 두번째로는 복호화 한 데이터를 객체형태로 만들기가 조금 귀찮다.</p><p>우선 복호화할때 옵션으로 0을 주면 utf-8형식으로 복호화가 되며, 정규식을 이용해서 쿼리 문자열 형식으로 변환후 객체로 변환했다.</p><p>우선 utf-8형식으로 나온 값의 형식은 <code>key=value\u001key=value...</code> 와같은데 정규식으로 <code>/\u001f/g</code>이용해서 <code>&amp;</code>으로 변경 후 <code>querystring</code>의 <code>parse</code>함수를 이용해서 객체로 변환해주면 된다.</p><p>이렇게 복호화한 데이터를 가지고 서버측 데이터를 수정해주면 되며, 수정까지 완료가 되면, 응답용 pug페이지를 이용해서 클라이언트에 알려주면된다.</p><p>이때 클라이언트 단은 크게 3가지가 있는데 일반 웹, Android, IOS 이렇게 3가지 환경이 있는데 이 모든 환경이 다르게 응답을 내려줘야 한다.</p><p>우선 웹에서는 보통 인증을 팝업을 띄어서 작업을 하기 때문에 부모 웹에 성공또는 실패 요청을 날려줘야 하고, Android나 IOS에서는 웹뷰를 띄우기 때문에 Android나 IOS에서 성공또는 실패 이벤트를 받을수 있도록 자바스크립트 이벤트를 날려줘야한다.</p><p>Android</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="string">&#x27;모바일에서 정의한 변수&#x27;</span>.<span class="string">&#x27;모바일에서 정의한 이벤트&#x27;</span>(<span class="string">&#x27;이벤트 내용&#x27;</span>)</span><br></pre></td></tr></table></figure><p>위와 같이 이용하면 된다. 참고로 Android에서 객체는 못 받아서 객체를 넘겨줘야하는 경우 <code>JSON.sstringify</code>을 이용하여 객체를 문자열로 컨버팅해서 전달해줘야한다.</p><p>IOS </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.<span class="string">&#x27;모바일에서 정의한 이벤트&#x27;</span>.<span class="title function_">postMessage</span>(이벤트 내용)</span><br></pre></td></tr></table></figure><p>위와 같이 사용이 가능하며, IOS에서는 객체를 받을수 있으며, 추가적으로는 비어있는 내용으로 함수를 보내는경우 <code>&#123;&#125;</code>이라도 추가를 해줘야 정상적으로 클라이언트에서 받는다.</p><p>Web</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">opener</span>.<span class="title function_">postMessage</span>(이벤트 내용,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><p>위와 같이 사용이 가능한데, 위 방식은 웹에서 popup을 이용하여 요청을 하며, 도메인이 다른경우에 cors 문제가 생겨서 위처럼 하였다. 이때, 이벤트 내용으로 민감한 내용은 보내지 않는겻을 추천한다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;현재 회사에서 나온 이슈인데, 하나의 고객이 SNS 로그인을 이용해서 여러개의 계정을 가지고 있어 히스토리가 분산이 되는 이슈가 있었다. 그래서 회사에서 KCP 본인 인증 서비스를 도입하면서 겪은 문제와 해결방법들등을 공유 한다. (더 좋은 방법</summary>
      
    
    
    
    
    <category term="Node" scheme="https://sungmun.github.io/blog/tags/Node/"/>
    
    <category term="KCP" scheme="https://sungmun.github.io/blog/tags/KCP/"/>
    
    <category term="본인인증" scheme="https://sungmun.github.io/blog/tags/%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D/"/>
    
  </entry>
  
  <entry>
    <title>Joi &amp; celebrate</title>
    <link href="https://sungmun.github.io/blog/2020/04/15/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%20%EC%9A%94%EC%B2%AD%20%EA%B2%80%EC%A6%9D,%20Joi%20&amp;%20celebrate/"/>
    <id>https://sungmun.github.io/blog/2020/04/15/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%20%EC%9A%94%EC%B2%AD%20%EA%B2%80%EC%A6%9D,%20Joi%20&amp;%20celebrate/</id>
    <published>2020-04-15T09:13:20.000Z</published>
    <updated>2024-01-19T07:37:03.829Z</updated>
    
    <content type="html"><![CDATA[<p>Node 로 Rest API 서버를 만들면서 일반적으로 제일 손이 많이 가는 작업은 클라이언트에서 보내는 요청에대한 검증 로직을 만드는 부분과 DB에 적절한 요청을 보내는 부분인데, 그중 클라이언트에서 보내는 요청에 대한 검증 로직을 보다 명확하고 깔끔하게 만들어주는 <code>@hapi/joi</code> 와 <code>@hapi/joi</code>를 express 에서 사용하기 좀더 쉽게 만들어주는 <code>celebrate</code> 를 이용해서 간단한 검증겸 잘못된 요청에 대해서 에러처리를 해보자</p><h2 id="시작"><a href="#시작" class="headerlink" title="시작"></a>시작</h2><p>서버에서 클라이언트에서 보내는 요청을 검증을 할 때, 검증을 하기 위해 필요한 부분은 우선적으로는 body 로 받을것인지 아니면 다른 형식으로 받을 것인지를 정하고 body 로 받는다면, 어떤 변수를 받을 것인지를 정해야 하며, 변수의 타입을 어떤식으로 받을것이며, 기본값은 무었으로 할것인지 등등을 정해줘야한다.</p><p>전부 정하면 서비스 로직에서 요청에대한 검증을 위한 코드로 검증을 하고 만약 틀리면 에러메세지를 보내는게 일반적인 검증 절차이다.</p><p>이때, <code>@hapi/joi</code>를 이용하면 서비스 로직과 검증 로직이 분리가 되며, 검증을 위한 로직이 없이 데이터의 타입이나 변수에대한 부분을 정의해놓은 스키마를 통해 가독성이 좋고 실수를 적게 할수 있다.</p><p>일반적으로 페이징 처리를 위한 쿼리에대한 검증 스키마이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pagingSchema = &#123;</span><br><span class="line">  <span class="attr">offset</span>: <span class="title class_">Joi</span>.<span class="title function_">number</span>().<span class="title function_">default</span>(<span class="number">0</span>).<span class="title function_">allow</span>(<span class="number">0</span>).<span class="title function_">label</span>(<span class="string">&#x27;검색 시작 범위&#x27;</span>),</span><br><span class="line">  <span class="attr">limit</span>: <span class="title class_">Joi</span>.<span class="title function_">number</span>().<span class="title function_">default</span>(<span class="number">30</span>).<span class="title function_">label</span>(<span class="string">&#x27;검색 갯수&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 검증 스키마는 변수 명으로 offset 과 limit 를 받을것이며, 위 두가지 변수는 모두 숫자형이어야하며, 없는경우 기본값으로 0,30 을 자동으로 넣어주며, offset의 경우 0이 들어와도 Error 처리를 하지 않겠다는 의미이다.</p><p>위 스키마를 검증을 하려면 다음과 같이 사용하면 된다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; error, value &#125; = Joi.object(pagingSchema).validate(req.query)</span><br></pre></td></tr></table></figure><p>여기에 추가적으로 <code>celebrate</code>를 이용하여 쿼리나 다른부분에 대해 검증스키마가 무었인지 정해주면 자동으로 에러처리를 해주게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Joi</span>, <span class="title class_">Segments</span>, celebrate &#125; <span class="keyword">from</span> <span class="string">&#x27;celebrate&#x27;</span>;</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="title function_">celebrate</span>(&#123;</span><br><span class="line">     [<span class="title class_">Segments</span>.<span class="property">QUERY</span>]:<span class="title class_">Joi</span>.<span class="title function_">object</span>(pagingSchema)</span><br><span class="line">&#125;),serviceLogic)</span><br></pre></td></tr></table></figure><p>이때 Joi는 <code>@hapi/joi</code>의 joi를 호출하면 않되고 <code>celebrate</code>의 joi 를 호출해서 사용해야 한다.</p><p><code>celebrate</code>를 이용하면 검증이 통과되지 않은 경우 자동으로 에러를 던지게 되며 express 의 경우 에러처리 미들웨어로 로직이 넘어간다.</p><p>이 경우에 에러 메세지가 joi에서 자체적으로 만든 에러가 전달이 된다. 이때 <code>isCelebrate(error)</code> 를 이용하면 joi에서 나오는 에러만 구분이 가능해지며, 이때 클라이언트에게 전달할 에러 메세지를 만들고 보낼수 있다.</p><h2 id="검증-스키마"><a href="#검증-스키마" class="headerlink" title="검증 스키마"></a>검증 스키마</h2><p>스키마는 보통 데이터 명, 데이터 타입, 데이터가 없는경우의 기본값, 그리고 제한사항 정도를 joi 형식에 맞게 만든다고 생각하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">데이터 명 : <span class="title class_">Joi</span>.데이터타입().<span class="title function_">default</span>(데이터가 없는경우의 기본값).그외의 제한사항</span><br></pre></td></tr></table></figure><p>위 와 같이 정의를 하면 된다.</p><p>이때, 그외의 제한사항 은 다음과 같이 chain 형식으로 작성을 해야한다.</p><ul><li>required() : 만약 요청시 없는경우에 에러</li><li>min() :  최소값 제한</li><li>max() :  최대값 제한</li><li>length() : 문자열 길이 제한</li><li>valid() : 허용하는 값의 목록 (ex. enum 같은 경우)</li><li>allow() : 검증 실패한 데이터의 경우 예외 데이터</li></ul><h3 id="팁"><a href="#팁" class="headerlink" title="팁"></a>팁</h3><p>우선은 기본적으로 모든 스키마는 joi.object를 통해서 묶어줘야 하며, 묶는부분은 파일에서 export 를 하는 부분에서 해주는게 좋다</p><p>포스트에 알려주는 방식은 주로 사용하는 검증 스키마이며, 공식 문서를 보면 훨씬 자유롭게 커스텀이 가능하다.</p><p>스키마는 별도의 파일로 분리해서 사용하는게 좋으며, 라우터를 분리하는 만큼 분리를 해야 가독성이 올라간다. 하나의 파일에 모든 스키마가 있으면 찾기가 좀 많이 힘들다.</p><p>그렇기 때문에 보통은 하나의 컨트롤러 또는 하나의 라우터당 한개의 스키마 파일을 사용하는것을 권한다.</p><p>그리고, 스키마 중 params 는 라우터(컨트롤러)당 겹치는 부분이 많아서 변수를 이용해서 분리를 해놓는게 좋다.</p><h2 id="Custom-Error"><a href="#Custom-Error" class="headerlink" title="Custom Error"></a>Custom Error</h2><p>에러 처리 방식은 매우 다양하지만 대부분 에러 코드나 서버에서 직접적으로 에러 메세지를 보내는 방식을 사용을 한다. 하지만 joi에서 보내는 에러 메세지를 그대로 전달을 하기에는 우선적으로는 영어여서 직관적이지 못하고, 검증에 통과하지 못한 변수명에 &#96;을 양쪽에 붙여서 보내서 상당히 성의가 없어 보인다는 단점이 있다. 그래서 자체적으로 에러 메세지를 만드는 것을 추천한다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="attr">err</span>: <span class="title class_">CelebrateInternalError</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; type, context, path, message &#125; = err.<span class="property">joi</span>.<span class="property">details</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/.required/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RequiredError</span>( <span class="string">`<span class="subst">$&#123;context.label&#125;</span>(<span class="subst">$&#123;context.key&#125;</span>) 값은(는) 필수값입니다`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/.base/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DataTypeError</span>( <span class="string">`<span class="subst">$&#123;context.label&#125;</span>(<span class="subst">$&#123;context.key&#125;</span>) 값은(는) <span class="subst">$&#123;type.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]&#125;</span> 타입 입니다`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/.length/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DataTypeError</span>(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;context.label&#125;</span>(<span class="subst">$&#123;context.key&#125;</span>) 값은(는) 길이는 <span class="subst">$&#123;context.limit&#125;</span>자리 이어야 합니다`</span>,</span><br><span class="line">         )</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/.min/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DataTypeError</span>(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;context.label&#125;</span>(<span class="subst">$&#123;context.key&#125;</span>) 값은(는) <span class="subst">$&#123;context.limit&#125;</span>보다 커야 합니다`</span>,</span><br><span class="line">          )</span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/.only/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DataTypeError</span>(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;context.label&#125;</span>(<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">              context.key</span></span></span><br><span class="line"><span class="subst"><span class="string">            &#125;</span>) 값은(는) 다음중 하나이어야 합니다 [<span class="subst">$&#123;context.valids.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>]`</span>,</span><br><span class="line">          )</span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`message: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`context.key: <span class="subst">$&#123;context.key&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`context.label: <span class="subst">$&#123;context.label&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`context.value: <span class="subst">$&#123;context.value&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`path: <span class="subst">$&#123;path&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`type: <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`err.joi.details[0]: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(err.joi.details[<span class="number">0</span>])&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestError</span>(message)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>만약 lodash를 사용한다면 다음과 같이 사용하는것도 좋다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joiTemplate = &#123;</span><br><span class="line">  <span class="string">&#x27;*&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">required</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;필수값입니다&#x27;</span>,</span><br><span class="line">    <span class="attr">base</span>: <span class="function">(<span class="params">&#123; type &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;type.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]&#125;</span> 타입 입니다`</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="function">(<span class="params">&#123; context &#125;</span>) =&gt;</span> <span class="string">`길이는 <span class="subst">$&#123;context.limit&#125;</span>자리 이어야 합니다`</span>,</span><br><span class="line">    <span class="attr">min</span>: <span class="function">(<span class="params">&#123; context &#125;</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;context.limit&#125;</span>보다 커야 합니다`</span>,</span><br><span class="line">    <span class="attr">only</span>: <span class="function">(<span class="params">&#123; context &#125;</span>) =&gt;</span> <span class="string">`다음중 하나이어야 합니다 [<span class="subst">$&#123;context.valids.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>]`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="attr">err</span>: <span class="title class_">CelebrateInternalError</span>)=&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, context, path, message &#125; = err.<span class="property">joi</span>.<span class="property">details</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> firstMessage = <span class="string">`<span class="subst">$&#123;context.label&#125;</span>(<span class="subst">$&#123;context.key&#125;</span>) 값은(는)`</span>;</span><br><span class="line">    <span class="keyword">const</span> [dataType, errorType] = type.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> lastMessageTemplate = _.<span class="title function_">get</span>(</span><br><span class="line">      joiTemplate,</span><br><span class="line">      [_.<span class="title function_">get</span>(joiTemplate, dataType, <span class="string">&#x27;*&#x27;</span>), errorType].<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BadRequestError</span>(message),</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lastMessageTemplate <span class="keyword">instanceof</span> <span class="title class_">BadRequestError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> lastMessageTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/.base|.length|.min|.only/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataTypeError</span>(<span class="string">`<span class="subst">$&#123;firstMessage&#125;</span> <span class="subst">$&#123;lastMessageTemplate(err.joi.details[<span class="number">0</span>])&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/.require/</span>.<span class="title function_">test</span>(type)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequiredError</span>(<span class="string">`<span class="subst">$&#123;firstMessage&#125;</span> <span class="subst">$&#123;lastMessageTemplate()&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Node 로 Rest API 서버를 만들면서 일반적으로 제일 손이 많이 가는 작업은 클라이언트에서 보내는 요청에대한 검증 로직을 만드는 부분과 DB에 적절한 요청을 보내는 부분인데, 그중 클라이언트에서 보내는 요청에 대한 검증 로직을 보다 명확하</summary>
      
    
    
    
    
    <category term="Node" scheme="https://sungmun.github.io/blog/tags/Node/"/>
    
    <category term="celebrate" scheme="https://sungmun.github.io/blog/tags/celebrate/"/>
    
    <category term="Joi" scheme="https://sungmun.github.io/blog/tags/Joi/"/>
    
  </entry>
  
</feed>
